<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Shape Builder</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
  body {
    margin: 0;
    font-family: system-ui, sans-serif;
    text-align: center;
    color: white;
    background: #0f1220;
    transition: background 0.6s;
    overscroll-behavior: none;
  }
  canvas {
    display: block;
    margin: 12px auto;
    border-radius: 16px;
    touch-action: none;
    transition: opacity 0.6s;
  }
  button {
    padding: 8px 12px;
    margin: 4px;
    border-radius: 8px;
    border: none;
    font-size: 14px;
  }
  #narration { opacity: 0.85; font-size: 14px; }
</style>
</head>
<body>

<h2>Shape Builder</h2>
<p id="modeLabel"></p>
<p id="hud"></p>
<p id="narration"></p>

<button onclick="restart()">Restart</button>
<button onclick="toggleMusic()">Music</button>
<button onclick="rotateSelected(-1)">‚Ü∫</button>
<button onclick="rotateSelected(1)">‚Üª</button>

<canvas id="game" width="360" height="520"></canvas>

<script>
/* ================= THEMES ================= */
const themes = [
  { bg:"#0f1220", canvas:"#171a2f", piece:"#7ae3ff", target:"#2a2f66", glow:"#6aff9c" },
  { bg:"#10261c", canvas:"#163f2a", piece:"#9dffb0", target:"#2a6644", glow:"#d6ffea" },
  { bg:"#261c10", canvas:"#3f2a16", piece:"#ffd89d", target:"#66502a", glow:"#fff0d6" }
];
let theme = themes[0];

/* ================= NARRATION ================= */
const narrationLines = [
  "Take your time.",
  "That feels close.",
  "Let it settle.",
  "Nice placement.",
  "You‚Äôre doing great."
];

/* ================= CANVAS ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

/* ================= GAME STATE ================= */
let pieces = [];
let targets = [];
let selected = null;
let level = 1;
let stars = 0;
let timeLeft = 60;
let timerId = null;
let transitioning = false;

/* Difficulty */
let SNAP_DIST = 32;
let SNAP_ROT = 0.4;
let MAGNET = 0.18;

/* ================= AUDIO ================= */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let musicOn = true;
let musicStarted = false;
let musicGain = null;

function toggleMusic() {
  musicOn = !musicOn;
  if (musicGain) musicGain.gain.value = musicOn ? 0.04 : 0;
}

const chords = [
  [220,277,330],
  [196,247,294],
  [174,220,261],
  [196,247,330]
];

function startMusic() {
  if (musicStarted || !musicOn) return;
  audioCtx.resume();
  musicStarted = true;

  musicGain = audioCtx.createGain();
  musicGain.gain.value = 0;
  musicGain.connect(audioCtx.destination);

  let i = 0;
  function play() {
    const g = audioCtx.createGain();
    g.gain.value = 0;
    g.connect(musicGain);

    chords[i].forEach((f,j)=>{
      const o = audioCtx.createOscillator();
      o.type = j ? "triangle" : "sine";
      o.frequency.value = f;
      o.connect(g);
      o.start();
      o.stop(audioCtx.currentTime + 8);
    });

    g.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + 3);
    g.gain.linearRampToValueAtTime(0.001, audioCtx.currentTime + 7.8);

    i = (i+1)%chords.length;
    setTimeout(play,8000);
  }

  musicGain.gain.linearRampToValueAtTime(0.04, audioCtx.currentTime + 5);
  play();
}

function blip(freq=500) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.frequency.value = freq;
  o.connect(g); g.connect(audioCtx.destination);
  g.gain.value = 0.2;
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
  o.start(); o.stop(audioCtx.currentTime + 0.1);
}

function haptic(ms=15) {
  if (navigator.vibrate) navigator.vibrate(ms);
}

/* ================= ANGLES ================= */
function angleDiff(a,b){
  let d = Math.abs(a-b)%(Math.PI*2);
  return d>Math.PI?Math.PI*2-d:d;
}
function squareAngleDiff(a,b){
  const s = Math.PI/2;
  return Math.min(
    angleDiff(a,b),
    angleDiff(a,b+s),
    angleDiff(a,b+s*2),
    angleDiff(a,b+s*3)
  );
}

/* ================= PIECE ================= */
class Piece {
  constructor(t,x,y,r,target){
    this.t=t; this.x=x; this.y=y; this.r=r;
    this.target=target;
    this.locked=false;
    this.glow=0;
    this.float=0;
  }

  rotationError(){
    if(this.t==="circle") return 0;
    if(this.t==="square") return squareAngleDiff(this.r,this.target.r);
    return angleDiff(this.r,this.target.r);
  }

  draw(){
    ctx.save();
    ctx.translate(this.x,this.y-this.float);
    ctx.rotate(this.r);

    ctx.beginPath();
    if(this.t==="square") ctx.rect(-24,-24,48,48);
    if(this.t==="triangle"){
      ctx.moveTo(0,-28);
      ctx.lineTo(28,28);
      ctx.lineTo(-28,28);
      ctx.closePath();
    }
    if(this.t==="circle") ctx.arc(0,0,24,0,Math.PI*2);

    if(this.glow>0){
      ctx.shadowColor = theme.glow;
      ctx.shadowBlur = this.glow;
      this.glow *= 0.85;
    }

    ctx.fillStyle = this.locked ? theme.glow : theme.piece;
    ctx.fill();
    ctx.strokeStyle = "white";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
  }

  contains(x,y){
    return Math.hypot(x-this.x,y-this.y) < 32;
  }

  updateMagnet(){
    const dx=this.target.x-this.x;
    const dy=this.target.y-this.y;
    if(Math.hypot(dx,dy)<SNAP_DIST*1.5){
      this.x+=dx*MAGNET;
      this.y+=dy*MAGNET;
      this.glow=18;
    }
  }

  trySnap(){
    if(
      Math.hypot(this.x-this.target.x,this.y-this.target.y)<SNAP_DIST &&
      this.rotationError()<SNAP_ROT
    ){
      this.x=this.target.x;
      this.y=this.target.y;
      this.r=this.target.r;
      this.locked=true;
      this.glow=40;
      blip(600);
      haptic();
      checkWin();
    }
  }
}

/* ================= LEVELS ================= */
const bonusBlueprints = [
  {name:"Cat üê±",parts:[
    {t:"circle",x:180,y:220,r:0},
    {t:"triangle",x:145,y:195,r:-0.6},
    {t:"triangle",x:215,y:195,r:0.6},
    {t:"square",x:180,y:275,r:0}
  ]},
  {name:"Fish üêü",parts:[
    {t:"circle",x:180,y:240,r:0},
    {t:"triangle",x:230,y:240,r:Math.PI/2},
    {t:"triangle",x:130,y:240,r:-Math.PI/2}
  ]}
];

function generateRandomTargets(){
  targets=[];
  const count=Math.min(3+Math.floor(level/3),7);
  for(let i=0;i<count;i++){
    targets.push({
      t:["circle","square","triangle"][Math.floor(Math.random()*3)],
      x:110+(i%3)*70,
      y:180+Math.floor(i/3)*70,
      r:Math.random()*Math.PI*2
    });
  }
}

function generateLevel(){
  transitioning=false;
  canvas.style.opacity=1;
  pieces=[];
  theme = themes[level % themes.length];
  document.body.style.background = theme.bg;
  canvas.style.background = theme.canvas;

  SNAP_DIST=Math.max(18,32-level*1.2);
  SNAP_ROT=Math.max(0.18,0.4-level*0.01);
  MAGNET=Math.max(0.08,0.18-level*0.005);

  if(level%5===0){
    const bp=bonusBlueprints[Math.floor(Math.random()*bonusBlueprints.length)];
    targets=bp.parts;
    timeLeft=90;
    document.getElementById("modeLabel").innerText="‚≠ê Bonus Level: "+bp.name;
  } else {
    generateRandomTargets();
    timeLeft=Math.max(30,70-level*3);
    document.getElementById("modeLabel").innerText="Relax and fit the pieces";
  }

  targets.forEach((t,i)=>{
    pieces.push(new Piece(
      t.t, 60+i*60, 450, Math.random()*Math.PI*2, t
    ));
  });

  document.getElementById("narration").innerText =
    narrationLines[Math.floor(Math.random()*narrationLines.length)];

  startTimer();
}

/* ================= TIMER ================= */
function startTimer(){
  clearInterval(timerId);
  timerId=setInterval(()=>{
    timeLeft--;
    if(timeLeft<=0){
      clearInterval(timerId);
      document.getElementById("narration").innerText="Let‚Äôs try again.";
      transitionOut(generateLevel);
    }
  },1000);
}

/* ================= TRANSITION ================= */
function transitionOut(next){
  transitioning=true;
  canvas.style.opacity=0;
  let t=0;
  const anim=setInterval(()=>{
    t++;
    pieces.forEach(p=>p.float+=2);
    if(t>30){
      clearInterval(anim);
      next();
    }
  },16);
}

/* ================= INPUT ================= */
let lastTouchAngle=null;

function rotateSelected(dir){
  if(!selected||selected.locked) return;
  selected.r+=dir*0.15;
}

function getPos(e){
  const r=canvas.getBoundingClientRect();
  if(e.touches){
    return {
      x:e.touches[0].clientX-r.left,
      y:e.touches[0].clientY-r.top
    };
  }
  return {x:e.clientX-r.left,y:e.clientY-r.top};
}

function startSelect(e){
  e.preventDefault();
  startMusic();
  const p=getPos(e);
  selected=pieces.find(pc=>!pc.locked&&pc.contains(p.x,p.y));
  if(e.touches&&e.touches.length===2&&selected){
    const a=e.touches[0],b=e.touches[1];
    lastTouchAngle=Math.atan2(b.clientY-a.clientY,b.clientX-a.clientX);
  } else lastTouchAngle=null;
}

function moveSelect(e){
  if(!selected||transitioning) return;
  e.preventDefault();
  const r=canvas.getBoundingClientRect();

  if(e.touches&&e.touches.length===2&&lastTouchAngle!==null){
    const a=e.touches[0],b=e.touches[1];
    const ang=Math.atan2(b.clientY-a.clientY,b.clientX-a.clientX);
    selected.r+=ang-lastTouchAngle;
    lastTouchAngle=ang;
  } else {
    const p=getPos(e);
    selected.x=p.x;
    selected.y=p.y;
    selected.updateMagnet();
  }
}

function endSelect(){
  if(selected) selected.trySnap();
  selected=null;
  lastTouchAngle=null;
}

canvas.addEventListener("mousedown",startSelect);
canvas.addEventListener("mousemove",moveSelect);
canvas.addEventListener("mouseup",endSelect);

canvas.addEventListener("touchstart",startSelect,{passive:false});
canvas.addEventListener("touchmove",moveSelect,{passive:false});
canvas.addEventListener("touchend",endSelect);

/* ================= WIN ================= */
function checkWin(){
  if(pieces.every(p=>p.locked)){
    clearInterval(timerId);
    stars++;
    document.getElementById("narration").innerText="That felt good.";
    blip(900);
    haptic(40);
    transitionOut(()=>{level++;generateLevel();});
  }
}
window.addEventListener("keydown", e => {
  if (!selected || selected.locked) return;

  if (e.key === "q" || e.key === "Q") {
    selected.r -= 0.15;
  }
  if (e.key === "e" || e.key === "E") {
    selected.r += 0.15;
  }
});

/* ================= LOOP ================= */
function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle=theme.target;
  targets.forEach(t=>{
    ctx.save();
    ctx.translate(t.x,t.y);
    ctx.rotate(t.r);
    ctx.beginPath();
    if(t.t==="square") ctx.rect(-24,-24,48,48);
    if(t.t==="triangle"){
      ctx.moveTo(0,-28);ctx.lineTo(28,28);ctx.lineTo(-28,28);ctx.closePath();
    }
    if(t.t==="circle") ctx.arc(0,0,24,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  });

  pieces.forEach(p=>p.draw());

  document.getElementById("hud").innerText =
    `Level ${level} ‚Ä¢ ‚≠ê ${stars} ‚Ä¢ ‚è± ${timeLeft}s`;

  requestAnimationFrame(loop);
}

/* ================= START ================= */
generateLevel();
loop();
</script>

</body>
</html>
